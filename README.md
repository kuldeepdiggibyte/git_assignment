<h3> This is assignment which contains 5 question</h3>
<p> <strong>in assignment_1</strong><br>
<strong>step 1:</strong>Initialized a new Git repository.<br>
<strong>step 2:</strong>Added a file and committed changes.<br>
<strong>step 3:</strong>Viewed the commit history.<br>
<strong>step 4:</strong>Modified the file.<br>
<strong>step 5:</strong>Verified the file was marked as “modified” and unstaged.<br>
<strong>step 6:</strong>Staged and committed the changes.<br>
<strong>step 7:</strong>Cloned the repository from GitHub.<br>
<strong>step 8:</strong>Fetched updates from the original repository.<br>
<strong>step 9:</strong>Pulled changes into your local copy.</p>
<br>
<p>in assignment_2 
  
1. **Cloned the Repository from GitHub**:
   - I initiated the process by cloning the repository from GitHub, creating a local copy on my machine.

2. **Created a New Branch**:
   - I used the command to create a new branch. This allowed me to work on a separate branch without affecting the main codebase.

3. **Switched to the New Branch**:
   - I switched to the newly created branch using the appropriate Git command. This ensured that my changes would be isolated to this branch.

4. **Made Changes to the Code**:
   - Within my local copy of the repository, I modified the code according to the task or feature I was working on.

5. **Committed Changes to the New Branch**:
   - After making the necessary changes, I committed them to the new branch. Each commit had a descriptive message explaining the purpose of the changes.

6. **Switched Back to the Original Branch**:
   - To return to the original branch (usually the main or master branch), I used the Git command to switch back.

7. **Merged the New Branch**:
   - Once I was satisfied with the changes in the new branch, I merged it back into the original branch. This combined my work with the existing codebase.

8. **Pushed Changes to the Original Branch**:
   - I pushed the changes to the original branch on GitHub, ensuring that they were reflected in the remote repository.
</p>
<br>
<p>
  Assignment_3

  Resolve the Conflict Locally:
When the pull request encounters a conflict, I’ll manually resolve it by editing the affected files.
Continue the Rebase:
git rebase --continue

This command instructs Git to proceed with applying the remaining commits from the pull request.

Push the Updated Branch:
Once everything is resolved, pushed the updated branch to the remote repository:
git push origin feature-branch

Update the Pull Request:
Back in the pull request on GitHub, the conflict should now be resolved.

</p><br>
<p><strong>assignment_4</strong> <br>
  <strong>step1 :</strong>Create a Feature Branch <br>
<strong>step2:</strong>Switch to the New Branch<br>
 I switched to the feature-branch.<br>
<strong>step 3:</strong>I added and committed these changes to the feature-branch.<br>
<strong>step 4:</strong>Using git cherry-pick,<br> 
  <strong>step 5:</strong>I applied the changes from the identified commits to the target branch.
</p><br>
<p> <strong>Assignment_5</strong><br> 
Create a Feature Branch
Within my local copy of the repository,<br> I opened the file and made necessary changes to the code.
<br>I added and committed these changes to the feature-branch.
<br>Resetting Commits:
I used the git reset command to move the branch pointer to a different commit.
The specific commit I wanted to reset to was identified using its hash.
<br>Verifying the Reset:
I verified that the reset was successful by checking the commit history using git log.
The commit hash or reference was provided as an argument to git revert.
</p>
